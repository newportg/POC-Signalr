{"ast":null,"code":"\"use strict\"; // Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\NEWPORTG\\\\source\\\\Personal\\\\Azure Functions\\\\POC-Sendmail\\\\Src\\\\Viewer-App\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchHttpClient = void 0;\n\nconst Errors_1 = require(\"./Errors\");\n\nconst HttpClient_1 = require(\"./HttpClient\");\n\nconst ILogger_1 = require(\"./ILogger\");\n\nconst Utils_1 = require(\"./Utils\");\n\nclass FetchHttpClient extends HttpClient_1.HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      this._fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind(Utils_1.getGlobalThis());\n    }\n\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n      this._abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n\n\n  send(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Check that abort was not signaled before calling send\n      if (request.abortSignal && request.abortSignal.aborted) {\n        throw new Errors_1.AbortError();\n      }\n\n      if (!request.method) {\n        throw new Error(\"No method defined.\");\n      }\n\n      if (!request.url) {\n        throw new Error(\"No url defined.\");\n      }\n\n      const abortController = new _this._abortControllerType();\n      let error; // Hook our abortSignal into the abort controller\n\n      if (request.abortSignal) {\n        request.abortSignal.onabort = () => {\n          abortController.abort();\n          error = new Errors_1.AbortError();\n        };\n      } // If a timeout has been passed in, setup a timeout to call abort\n      // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n\n\n      let timeoutId = null;\n\n      if (request.timeout) {\n        const msTimeout = request.timeout;\n        timeoutId = setTimeout(() => {\n          abortController.abort();\n\n          _this._logger.log(ILogger_1.LogLevel.Warning, `Timeout from HTTP request.`);\n\n          error = new Errors_1.TimeoutError();\n        }, msTimeout);\n      }\n\n      if (request.content === \"\") {\n        request.content = undefined;\n      }\n\n      if (request.content) {\n        // Explicitly setting the Content-Type header for React Native on Android platform.\n        request.headers = request.headers || {};\n\n        if (Utils_1.isArrayBuffer(request.content)) {\n          request.headers[\"Content-Type\"] = \"application/octet-stream\";\n        } else {\n          request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n        }\n      }\n\n      let response;\n\n      try {\n        response = yield _this._fetchType(request.url, {\n          body: request.content,\n          cache: \"no-cache\",\n          credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n          headers: {\n            \"X-Requested-With\": \"XMLHttpRequest\",\n            ...request.headers\n          },\n          method: request.method,\n          mode: \"cors\",\n          redirect: \"follow\",\n          signal: abortController.signal\n        });\n      } catch (e) {\n        if (error) {\n          throw error;\n        }\n\n        _this._logger.log(ILogger_1.LogLevel.Warning, `Error from HTTP request. ${e}.`);\n\n        throw e;\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n      }\n\n      if (!response.ok) {\n        const errorMessage = yield deserializeContent(response, \"text\");\n        throw new Errors_1.HttpError(errorMessage || response.statusText, response.status);\n      }\n\n      const content = deserializeContent(response, request.responseType);\n      const payload = yield content;\n      return new HttpClient_1.HttpResponse(response.status, response.statusText, payload);\n    })();\n  }\n\n  getCookieString(url) {\n    let cookies = \"\";\n\n    if (Utils_1.Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n\n    return cookies;\n  }\n\n}\n\nexports.FetchHttpClient = FetchHttpClient;\n\nfunction deserializeContent(response, responseType) {\n  let content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${responseType} is not supported.`);\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n}","map":{"version":3,"sources":["C:/Users/NEWPORTG/source/Personal/Azure Functions/POC-Sendmail/node_modules/@microsoft/signalr/dist/cjs/FetchHttpClient.js"],"names":["Object","defineProperty","exports","value","FetchHttpClient","Errors_1","require","HttpClient_1","ILogger_1","Utils_1","HttpClient","constructor","logger","_logger","fetch","requireFunc","__webpack_require__","__non_webpack_require__","_jar","CookieJar","_fetchType","bind","getGlobalThis","AbortController","_abortControllerType","send","request","abortSignal","aborted","AbortError","method","Error","url","abortController","error","onabort","abort","timeoutId","timeout","msTimeout","setTimeout","log","LogLevel","Warning","TimeoutError","content","undefined","headers","isArrayBuffer","response","body","cache","credentials","withCredentials","mode","redirect","signal","e","clearTimeout","ok","errorMessage","deserializeContent","HttpError","statusText","status","responseType","payload","HttpResponse","getCookieString","cookies","Platform","isNode","getCookies","c","join","arrayBuffer","text"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FetchHttpClient = void 0;\r\nconst Errors_1 = require(\"./Errors\");\r\nconst HttpClient_1 = require(\"./HttpClient\");\r\nconst ILogger_1 = require(\"./ILogger\");\r\nconst Utils_1 = require(\"./Utils\");\r\nclass FetchHttpClient extends HttpClient_1.HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(Utils_1.getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        }\r\n        else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new Errors_1.AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new Errors_1.AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(ILogger_1.LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new Errors_1.TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (Utils_1.isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }\r\n            else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(ILogger_1.LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new Errors_1.HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpClient_1.HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Utils_1.Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nexports.FetchHttpClient = FetchHttpClient;\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}