{"ast":null,"code":"\"use strict\"; // Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\NEWPORTG\\\\source\\\\Personal\\\\Azure Functions\\\\POC-Sendmail\\\\Src\\\\Viewer-App\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerSentEventsTransport = void 0;\n\nconst ILogger_1 = require(\"./ILogger\");\n\nconst ITransport_1 = require(\"./ITransport\");\n\nconst Utils_1 = require(\"./Utils\");\n/** @private */\n\n\nclass ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  connect(url, transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      Utils_1.Arg.isRequired(url, \"url\");\n      Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\n      Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\n\n      _this._logger.log(ILogger_1.LogLevel.Trace, \"(SSE transport) Connecting.\"); // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n\n\n      _this._url = url;\n\n      if (_this._accessToken) {\n        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(_this._accessToken)}`;\n      }\n\n      return new Promise((resolve, reject) => {\n        let opened = false;\n\n        if (transferFormat !== ITransport_1.TransferFormat.Text) {\n          reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n          return;\n        }\n\n        let eventSource;\n\n        if (Utils_1.Platform.isBrowser || Utils_1.Platform.isWebWorker) {\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials\n          });\n        } else {\n          // Non-browser passes cookies via the dictionary\n          const cookies = _this._httpClient.getCookieString(url);\n\n          const headers = {};\n          headers.Cookie = cookies;\n          const [name, value] = Utils_1.getUserAgentHeader();\n          headers[name] = value;\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials,\n            headers: { ...headers,\n              ..._this._options.headers\n            }\n          });\n        }\n\n        try {\n          eventSource.onmessage = e => {\n            if (_this.onreceive) {\n              try {\n                _this._logger.log(ILogger_1.LogLevel.Trace, `(SSE transport) data received. ${Utils_1.getDataDetail(e.data, _this._options.logMessageContent)}.`);\n\n                _this.onreceive(e.data);\n              } catch (error) {\n                _this._close(error);\n\n                return;\n              }\n            }\n          }; // @ts-ignore: not using event on purpose\n\n\n          eventSource.onerror = e => {\n            // EventSource doesn't give any useful information about server side closes.\n            if (opened) {\n              _this._close();\n            } else {\n              reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n            }\n          };\n\n          eventSource.onopen = () => {\n            _this._logger.log(ILogger_1.LogLevel.Information, `SSE connected to ${_this._url}`);\n\n            _this._eventSource = eventSource;\n            opened = true;\n            resolve();\n          };\n        } catch (e) {\n          reject(e);\n          return;\n        }\n      });\n    })();\n  }\n\n  send(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2._eventSource) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n\n      return Utils_1.sendMessage(_this2._logger, \"SSE\", _this2._httpClient, _this2._url, data, _this2._options);\n    })();\n  }\n\n  stop() {\n    this._close();\n\n    return Promise.resolve();\n  }\n\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n\n      this._eventSource = undefined;\n\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n\n}\n\nexports.ServerSentEventsTransport = ServerSentEventsTransport;","map":{"version":3,"sources":["C:/Users/NEWPORTG/source/Personal/Azure Functions/POC-Sendmail/node_modules/@microsoft/signalr/dist/cjs/ServerSentEventsTransport.js"],"names":["Object","defineProperty","exports","value","ServerSentEventsTransport","ILogger_1","require","ITransport_1","Utils_1","constructor","httpClient","accessToken","logger","options","_httpClient","_accessToken","_logger","_options","onreceive","onclose","connect","url","transferFormat","Arg","isRequired","isIn","TransferFormat","log","LogLevel","Trace","_url","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","Platform","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","getUserAgentHeader","onmessage","e","getDataDetail","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","sendMessage","stop","close","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ServerSentEventsTransport = void 0;\r\nconst ILogger_1 = require(\"./ILogger\");\r\nconst ITransport_1 = require(\"./ITransport\");\r\nconst Utils_1 = require(\"./Utils\");\r\n/** @private */\r\nclass ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Utils_1.Arg.isRequired(url, \"url\");\r\n        Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\r\n        this._logger.log(ILogger_1.LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== ITransport_1.TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Utils_1.Platform.isBrowser || Utils_1.Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = Utils_1.getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(ILogger_1.LogLevel.Trace, `(SSE transport) data received. ${Utils_1.getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(ILogger_1.LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return Utils_1.sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.ServerSentEventsTransport = ServerSentEventsTransport;\r\n"]},"metadata":{},"sourceType":"script"}