{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\NEWPORTG\\\\source\\\\Personal\\\\CloudEventSubscription\\\\Src\\\\Viewer-App\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { HttpClient } from \"./HttpClient\";\n/** @private */\n\nexport class AccessTokenHttpClient extends HttpClient {\n  constructor(innerClient, accessTokenFactory) {\n    super();\n    this._innerClient = innerClient;\n    this._accessTokenFactory = accessTokenFactory;\n  }\n\n  send(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let allowRetry = true;\n\n      if (_this._accessTokenFactory && (!_this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0)) {\n        // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n        allowRetry = false;\n        _this._accessToken = yield _this._accessTokenFactory();\n      }\n\n      _this._setAuthorizationHeader(request);\n\n      const response = yield _this._innerClient.send(request);\n\n      if (allowRetry && response.statusCode === 401 && _this._accessTokenFactory) {\n        _this._accessToken = yield _this._accessTokenFactory();\n\n        _this._setAuthorizationHeader(request);\n\n        return yield _this._innerClient.send(request);\n      }\n\n      return response;\n    })();\n  }\n\n  _setAuthorizationHeader(request) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n\n    if (this._accessToken) {\n      request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\n    } // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n    else if (this._accessTokenFactory) {\n      if (request.headers[HeaderNames.Authorization]) {\n        delete request.headers[HeaderNames.Authorization];\n      }\n    }\n  }\n\n  getCookieString(url) {\n    return this._innerClient.getCookieString(url);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/NEWPORTG/source/Personal/CloudEventSubscription/node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js"],"names":["HeaderNames","HttpClient","AccessTokenHttpClient","constructor","innerClient","accessTokenFactory","_innerClient","_accessTokenFactory","send","request","allowRetry","_accessToken","url","indexOf","_setAuthorizationHeader","response","statusCode","headers","Authorization","getCookieString"],"mappings":";AAAA;AACA;AACA,SAASA,WAAT,QAA4B,eAA5B;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA;;AACA,OAAO,MAAMC,qBAAN,SAAoCD,UAApC,CAA+C;AAClDE,EAAAA,WAAW,CAACC,WAAD,EAAcC,kBAAd,EAAkC;AACzC;AACA,SAAKC,YAAL,GAAoBF,WAApB;AACA,SAAKG,mBAAL,GAA2BF,kBAA3B;AACH;;AACKG,EAAAA,IAAI,CAACC,OAAD,EAAU;AAAA;;AAAA;AAChB,UAAIC,UAAU,GAAG,IAAjB;;AACA,UAAI,KAAI,CAACH,mBAAL,KAA6B,CAAC,KAAI,CAACI,YAAN,IAAuBF,OAAO,CAACG,GAAR,IAAeH,OAAO,CAACG,GAAR,CAAYC,OAAZ,CAAoB,aAApB,IAAqC,CAAxG,CAAJ,EAAiH;AAC7G;AACAH,QAAAA,UAAU,GAAG,KAAb;AACA,QAAA,KAAI,CAACC,YAAL,SAA0B,KAAI,CAACJ,mBAAL,EAA1B;AACH;;AACD,MAAA,KAAI,CAACO,uBAAL,CAA6BL,OAA7B;;AACA,YAAMM,QAAQ,SAAS,KAAI,CAACT,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAvB;;AACA,UAAIC,UAAU,IAAIK,QAAQ,CAACC,UAAT,KAAwB,GAAtC,IAA6C,KAAI,CAACT,mBAAtD,EAA2E;AACvE,QAAA,KAAI,CAACI,YAAL,SAA0B,KAAI,CAACJ,mBAAL,EAA1B;;AACA,QAAA,KAAI,CAACO,uBAAL,CAA6BL,OAA7B;;AACA,qBAAa,KAAI,CAACH,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAb;AACH;;AACD,aAAOM,QAAP;AAdgB;AAenB;;AACDD,EAAAA,uBAAuB,CAACL,OAAD,EAAU;AAC7B,QAAI,CAACA,OAAO,CAACQ,OAAb,EAAsB;AAClBR,MAAAA,OAAO,CAACQ,OAAR,GAAkB,EAAlB;AACH;;AACD,QAAI,KAAKN,YAAT,EAAuB;AACnBF,MAAAA,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,IAA8C,UAAS,KAAKP,YAAa,EAAzE;AACH,KAFD,CAGA;AAHA,SAIK,IAAI,KAAKJ,mBAAT,EAA8B;AAC/B,UAAIE,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,CAAJ,EAAgD;AAC5C,eAAOT,OAAO,CAACQ,OAAR,CAAgBjB,WAAW,CAACkB,aAA5B,CAAP;AACH;AACJ;AACJ;;AACDC,EAAAA,eAAe,CAACP,GAAD,EAAM;AACjB,WAAO,KAAKN,YAAL,CAAkBa,eAAlB,CAAkCP,GAAlC,CAAP;AACH;;AAtCiD","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    constructor(innerClient, accessTokenFactory) {\r\n        super();\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n    async send(request) {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n    _setAuthorizationHeader(request) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n    getCookieString(url) {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}