{"ast":null,"code":"\"use strict\"; // Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\NEWPORTG\\\\source\\\\Personal\\\\Azure Functions\\\\POC-Sendmail\\\\Src\\\\Viewer-App\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccessTokenHttpClient = void 0;\n\nconst HeaderNames_1 = require(\"./HeaderNames\");\n\nconst HttpClient_1 = require(\"./HttpClient\");\n/** @private */\n\n\nclass AccessTokenHttpClient extends HttpClient_1.HttpClient {\n  constructor(innerClient, accessTokenFactory) {\n    super();\n    this._innerClient = innerClient;\n    this._accessTokenFactory = accessTokenFactory;\n  }\n\n  send(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let allowRetry = true;\n\n      if (_this._accessTokenFactory && (!_this._accessToken || request.url && request.url.indexOf(\"/negotiate?\") > 0)) {\n        // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n        allowRetry = false;\n        _this._accessToken = yield _this._accessTokenFactory();\n      }\n\n      _this._setAuthorizationHeader(request);\n\n      const response = yield _this._innerClient.send(request);\n\n      if (allowRetry && response.statusCode === 401 && _this._accessTokenFactory) {\n        _this._accessToken = yield _this._accessTokenFactory();\n\n        _this._setAuthorizationHeader(request);\n\n        return yield _this._innerClient.send(request);\n      }\n\n      return response;\n    })();\n  }\n\n  _setAuthorizationHeader(request) {\n    if (!request.headers) {\n      request.headers = {};\n    }\n\n    if (this._accessToken) {\n      request.headers[HeaderNames_1.HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\n    } // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n    else if (this._accessTokenFactory) {\n      if (request.headers[HeaderNames_1.HeaderNames.Authorization]) {\n        delete request.headers[HeaderNames_1.HeaderNames.Authorization];\n      }\n    }\n  }\n\n  getCookieString(url) {\n    return this._innerClient.getCookieString(url);\n  }\n\n}\n\nexports.AccessTokenHttpClient = AccessTokenHttpClient;","map":{"version":3,"sources":["C:/Users/NEWPORTG/source/Personal/Azure Functions/POC-Sendmail/node_modules/@microsoft/signalr/dist/cjs/AccessTokenHttpClient.js"],"names":["Object","defineProperty","exports","value","AccessTokenHttpClient","HeaderNames_1","require","HttpClient_1","HttpClient","constructor","innerClient","accessTokenFactory","_innerClient","_accessTokenFactory","send","request","allowRetry","_accessToken","url","indexOf","_setAuthorizationHeader","response","statusCode","headers","HeaderNames","Authorization","getCookieString"],"mappings":"AAAA,a,CACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgC,KAAK,CAArC;;AACA,MAAMC,aAAa,GAAGC,OAAO,CAAC,eAAD,CAA7B;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,cAAD,CAA5B;AACA;;;AACA,MAAMF,qBAAN,SAAoCG,YAAY,CAACC,UAAjD,CAA4D;AACxDC,EAAAA,WAAW,CAACC,WAAD,EAAcC,kBAAd,EAAkC;AACzC;AACA,SAAKC,YAAL,GAAoBF,WAApB;AACA,SAAKG,mBAAL,GAA2BF,kBAA3B;AACH;;AACKG,EAAAA,IAAI,CAACC,OAAD,EAAU;AAAA;;AAAA;AAChB,UAAIC,UAAU,GAAG,IAAjB;;AACA,UAAI,KAAI,CAACH,mBAAL,KAA6B,CAAC,KAAI,CAACI,YAAN,IAAuBF,OAAO,CAACG,GAAR,IAAeH,OAAO,CAACG,GAAR,CAAYC,OAAZ,CAAoB,aAApB,IAAqC,CAAxG,CAAJ,EAAiH;AAC7G;AACAH,QAAAA,UAAU,GAAG,KAAb;AACA,QAAA,KAAI,CAACC,YAAL,SAA0B,KAAI,CAACJ,mBAAL,EAA1B;AACH;;AACD,MAAA,KAAI,CAACO,uBAAL,CAA6BL,OAA7B;;AACA,YAAMM,QAAQ,SAAS,KAAI,CAACT,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAvB;;AACA,UAAIC,UAAU,IAAIK,QAAQ,CAACC,UAAT,KAAwB,GAAtC,IAA6C,KAAI,CAACT,mBAAtD,EAA2E;AACvE,QAAA,KAAI,CAACI,YAAL,SAA0B,KAAI,CAACJ,mBAAL,EAA1B;;AACA,QAAA,KAAI,CAACO,uBAAL,CAA6BL,OAA7B;;AACA,qBAAa,KAAI,CAACH,YAAL,CAAkBE,IAAlB,CAAuBC,OAAvB,CAAb;AACH;;AACD,aAAOM,QAAP;AAdgB;AAenB;;AACDD,EAAAA,uBAAuB,CAACL,OAAD,EAAU;AAC7B,QAAI,CAACA,OAAO,CAACQ,OAAb,EAAsB;AAClBR,MAAAA,OAAO,CAACQ,OAAR,GAAkB,EAAlB;AACH;;AACD,QAAI,KAAKN,YAAT,EAAuB;AACnBF,MAAAA,OAAO,CAACQ,OAAR,CAAgBlB,aAAa,CAACmB,WAAd,CAA0BC,aAA1C,IAA4D,UAAS,KAAKR,YAAa,EAAvF;AACH,KAFD,CAGA;AAHA,SAIK,IAAI,KAAKJ,mBAAT,EAA8B;AAC/B,UAAIE,OAAO,CAACQ,OAAR,CAAgBlB,aAAa,CAACmB,WAAd,CAA0BC,aAA1C,CAAJ,EAA8D;AAC1D,eAAOV,OAAO,CAACQ,OAAR,CAAgBlB,aAAa,CAACmB,WAAd,CAA0BC,aAA1C,CAAP;AACH;AACJ;AACJ;;AACDC,EAAAA,eAAe,CAACR,GAAD,EAAM;AACjB,WAAO,KAAKN,YAAL,CAAkBc,eAAlB,CAAkCR,GAAlC,CAAP;AACH;;AAtCuD;;AAwC5DhB,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC","sourcesContent":["\"use strict\";\r\n// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AccessTokenHttpClient = void 0;\r\nconst HeaderNames_1 = require(\"./HeaderNames\");\r\nconst HttpClient_1 = require(\"./HttpClient\");\r\n/** @private */\r\nclass AccessTokenHttpClient extends HttpClient_1.HttpClient {\r\n    constructor(innerClient, accessTokenFactory) {\r\n        super();\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n    async send(request) {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n    _setAuthorizationHeader(request) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames_1.HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames_1.HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames_1.HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n    getCookieString(url) {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}\r\nexports.AccessTokenHttpClient = AccessTokenHttpClient;\r\n"]},"metadata":{},"sourceType":"script"}