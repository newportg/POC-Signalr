{"ast":null,"code":"\"use strict\"; // Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\NEWPORTG\\\\source\\\\Personal\\\\Azure Functions\\\\POC-Sendmail\\\\Src\\\\Viewer-App\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketTransport = void 0;\n\nconst HeaderNames_1 = require(\"./HeaderNames\");\n\nconst ILogger_1 = require(\"./ILogger\");\n\nconst ITransport_1 = require(\"./ITransport\");\n\nconst Utils_1 = require(\"./Utils\");\n/** @private */\n\n\nclass WebSocketTransport {\n  constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n\n  connect(url, transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      Utils_1.Arg.isRequired(url, \"url\");\n      Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\n      Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\n\n      _this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n\n      let token;\n\n      if (_this._accessTokenFactory) {\n        token = yield _this._accessTokenFactory();\n      }\n\n      return new Promise((resolve, reject) => {\n        url = url.replace(/^http/, \"ws\");\n        let webSocket;\n\n        const cookies = _this._httpClient.getCookieString(url);\n\n        let opened = false;\n\n        if (Utils_1.Platform.isNode || Utils_1.Platform.isReactNative) {\n          const headers = {};\n          const [name, value] = Utils_1.getUserAgentHeader();\n          headers[name] = value;\n\n          if (token) {\n            headers[HeaderNames_1.HeaderNames.Authorization] = `Bearer ${token}`;\n          }\n\n          if (cookies) {\n            headers[HeaderNames_1.HeaderNames.Cookie] = cookies;\n          } // Only pass headers when in non-browser environments\n\n\n          webSocket = new _this._webSocketConstructor(url, undefined, {\n            headers: { ...headers,\n              ..._this._headers\n            }\n          });\n        } else {\n          if (token) {\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n          }\n        }\n\n        if (!webSocket) {\n          // Chrome is not happy with passing 'undefined' as protocol\n          webSocket = new _this._webSocketConstructor(url);\n        }\n\n        if (transferFormat === ITransport_1.TransferFormat.Binary) {\n          webSocket.binaryType = \"arraybuffer\";\n        }\n\n        webSocket.onopen = _event => {\n          _this._logger.log(ILogger_1.LogLevel.Information, `WebSocket connected to ${url}.`);\n\n          _this._webSocket = webSocket;\n          opened = true;\n          resolve();\n        };\n\n        webSocket.onerror = event => {\n          let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n          if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n            error = event.error;\n          } else {\n            error = \"There was an error with the transport\";\n          }\n\n          _this._logger.log(ILogger_1.LogLevel.Information, `(WebSockets transport) ${error}.`);\n        };\n\n        webSocket.onmessage = message => {\n          _this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) data received. ${Utils_1.getDataDetail(message.data, _this._logMessageContent)}.`);\n\n          if (_this.onreceive) {\n            try {\n              _this.onreceive(message.data);\n            } catch (error) {\n              _this._close(error);\n\n              return;\n            }\n          }\n        };\n\n        webSocket.onclose = event => {\n          // Don't call close handler if connection was never established\n          // We'll reject the connect call instead\n          if (opened) {\n            _this._close(event);\n          } else {\n            let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n            if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n              error = event.error;\n            } else {\n              error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n            }\n\n            reject(new Error(error));\n          }\n        };\n      });\n    })();\n  }\n\n  send(data) {\n    if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n      this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) sending data. ${Utils_1.getDataDetail(data, this._logMessageContent)}.`);\n\n      this._webSocket.send(data);\n\n      return Promise.resolve();\n    }\n\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n\n  stop() {\n    if (this._webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this._close(undefined);\n    }\n\n    return Promise.resolve();\n  }\n\n  _close(event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this._webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this._webSocket.onclose = () => {};\n\n      this._webSocket.onmessage = () => {};\n\n      this._webSocket.onerror = () => {};\n\n      this._webSocket.close();\n\n      this._webSocket = undefined;\n    }\n\n    this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n\n    if (this.onclose) {\n      if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  }\n\n  _isCloseEvent(event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  }\n\n}\n\nexports.WebSocketTransport = WebSocketTransport;","map":{"version":3,"sources":["C:/Users/NEWPORTG/source/Personal/Azure Functions/POC-Sendmail/node_modules/@microsoft/signalr/dist/cjs/WebSocketTransport.js"],"names":["Object","defineProperty","exports","value","WebSocketTransport","HeaderNames_1","require","ILogger_1","ITransport_1","Utils_1","constructor","httpClient","accessTokenFactory","logger","logMessageContent","webSocketConstructor","headers","_logger","_accessTokenFactory","_logMessageContent","_webSocketConstructor","_httpClient","onreceive","onclose","_headers","connect","url","transferFormat","Arg","isRequired","isIn","TransferFormat","log","LogLevel","Trace","token","Promise","resolve","reject","replace","webSocket","cookies","getCookieString","opened","Platform","isNode","isReactNative","name","getUserAgentHeader","HeaderNames","Authorization","Cookie","undefined","indexOf","encodeURIComponent","Binary","binaryType","onopen","_event","Information","_webSocket","onerror","event","error","ErrorEvent","onmessage","message","getDataDetail","data","_close","Error","send","readyState","OPEN","stop","close","_isCloseEvent","wasClean","code","reason"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebSocketTransport = void 0;\r\nconst HeaderNames_1 = require(\"./HeaderNames\");\r\nconst ILogger_1 = require(\"./ILogger\");\r\nconst ITransport_1 = require(\"./ITransport\");\r\nconst Utils_1 = require(\"./Utils\");\r\n/** @private */\r\nclass WebSocketTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Utils_1.Arg.isRequired(url, \"url\");\r\n        Utils_1.Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Utils_1.Arg.isIn(transferFormat, ITransport_1.TransferFormat, \"transferFormat\");\r\n        this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n        let token;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n            if (Utils_1.Platform.isNode || Utils_1.Platform.isReactNative) {\r\n                const headers = {};\r\n                const [name, value] = Utils_1.getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames_1.HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n                if (cookies) {\r\n                    headers[HeaderNames_1.HeaderNames.Cookie] = cookies;\r\n                }\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n            if (transferFormat === ITransport_1.TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (_event) => {\r\n                this._logger.log(ILogger_1.LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                let error = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                }\r\n                else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n                this._logger.log(ILogger_1.LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) data received. ${Utils_1.getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    }\r\n                    catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                }\r\n                else {\r\n                    let error = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    }\r\n                    else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the endpoint may not be a SignalR endpoint,\"\r\n                            + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(ILogger_1.LogLevel.Trace, `(WebSockets transport) sending data. ${Utils_1.getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _close(event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => { };\r\n            this._webSocket.onmessage = () => { };\r\n            this._webSocket.onerror = () => { };\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n        this._logger.log(ILogger_1.LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            }\r\n            else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n    _isCloseEvent(event) {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\nexports.WebSocketTransport = WebSocketTransport;\r\n"]},"metadata":{},"sourceType":"script"}